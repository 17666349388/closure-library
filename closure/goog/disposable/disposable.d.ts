//!! generated by clutz.
// Generated from third_party/closure/goog/disposable/disposable.js
declare namespace ಠ_ಠ.clutz.goog {
  /**
   * Class that provides the basic implementation for disposable objects. If your
   * class holds references or resources that can't be collected by standard GC,
   * it should extend this class or implement the disposable interface (defined
   * in goog.disposable.IDisposable). See description of
   * goog.disposable.IDisposable for examples of cleanup.
   */
  class Disposable implements ಠ_ಠ.clutz.goog.disposable.IDisposable {
    private noStructuralTyping_goog_Disposable : any;
    /**
     * If monitoring the goog.Disposable instances is enabled, stores the creation
     * stack trace of the Disposable instance.
     */
    creationStack ? : string ;
    /**
     * Invokes a callback function when this object is disposed. Callbacks are
     * invoked in the order in which they were added. If a callback is added to
     * an already disposed Disposable, it will be called immediately.
     * @param callback The callback function.
     * @param opt_scope An optional scope to call the callback in.
     */
    addOnDisposeCallback < T = any > (callback : (this : T ) => any , opt_scope ? : T ) : void ;
    /**
     * Disposes of the object. If the object hasn't already been disposed of, calls
     * {@link #disposeInternal}. Classes that extend `goog.Disposable` should
     * override {@link #disposeInternal} in order to cleanup references, resources
     * and other disposable objects. Reentrant.
     */
    dispose ( ) : void ;
    /**
     * Performs appropriate cleanup. See description of goog.disposable.IDisposable
     * for examples. Classes that extend `goog.Disposable` should override this
     * method. Not reentrant. To avoid calling it twice, it must only be called from
     * the subclass' `disposeInternal` method. Everywhere else the public `dispose`
     * method must be used. For example:
     *
     * <pre>
     * mypackage.MyClass = function() {
     * mypackage.MyClass.base(this, 'constructor');
     * // Constructor logic specific to MyClass.
     * ...
     * };
     * goog.inherits(mypackage.MyClass, goog.Disposable);
     *
     * mypackage.MyClass.prototype.disposeInternal = function() {
     * // Dispose logic specific to MyClass.
     * ...
     * // Call superclass's disposeInternal at the end of the subclass's, like
     * // in C++, to avoid hard-to-catch issues.
     * mypackage.MyClass.base(this, 'disposeInternal');
     * };
     * </pre>
     */
    protected disposeInternal ( ) : void ;
    getDisposed ( ) : boolean ;
    isDisposed ( ) : boolean ;
    /**
     * Associates a disposable object with this object so that they will be disposed
     * together.
     * @param disposable that will be disposed when this object is disposed.
     */
    registerDisposable (disposable : ಠ_ಠ.clutz.goog.disposable.IDisposable | null ) : void ;
    static INCLUDE_STACK_ON_CREATION : boolean ;
    static MONITORING_MODE : number ;
    static clearUndisposedObjects ( ) : void ;
    static getUndisposedObjects ( ) : ಠ_ಠ.clutz.goog.Disposable [] ;
    /**
     * Returns True if we can verify the object is disposed.
     * Calls `isDisposed` on the argument if it supports it.  If obj
     * is not an object with an isDisposed() method, return false.
     * @param obj The object to investigate.
     */
    static isDisposed (obj : any ) : boolean ;
  }
}
// Generated from third_party/closure/goog/disposable/disposable.js
declare namespace ಠ_ಠ.clutz.goog.Disposable {
  enum MonitoringMode {
    INTERACTIVE = 2.0 ,
    OFF = 0.0 ,
    PERMANENT = 1.0 ,
  }
}
// Generated from third_party/closure/goog/disposable/disposable.js
declare module 'goog:goog.Disposable' {
  import Disposable = ಠ_ಠ.clutz.goog.Disposable;
  export default Disposable;
  const __clutz_actual_path: 'google3/third_party/closure/goog/disposable/disposable';
}
declare module 'google3/third_party/closure/goog/disposable/disposable' {
  import Disposable = ಠ_ಠ.clutz.goog.Disposable;
  export { Disposable };
  const __clutz_strip_property: 'Disposable';
  const __clutz_actual_namespace: 'goog.Disposable';
}
// Generated from third_party/closure/goog/disposable/disposable.js
declare namespace ಠ_ಠ.clutz.goog {
  /**
   * Calls `dispose` on the argument if it supports it. If obj is not an
   * object with a dispose() method, this is a no-op.
   * @param obj The object to dispose of.
   */
  function dispose (obj : any ) : void ;
}
// Generated from third_party/closure/goog/disposable/disposable.js
declare module 'goog:goog.dispose' {
  import dispose = ಠ_ಠ.clutz.goog.dispose;
  export default dispose;
}
declare module 'google3/third_party/closure/goog/disposable/disposable' {
  export {};
  const __clutz_multiple_provides: true;
}
// Generated from third_party/closure/goog/disposable/disposable.js
declare namespace ಠ_ಠ.clutz.goog {
  /**
   * Calls `dispose` on each member of the list that supports it. (If the
   * member is an ArrayLike, then `goog.disposeAll()` will be called
   * recursively on each of its members.) If the member is not an object with a
   * `dispose()` method, then it is ignored.
   * @param var_args The list.
   */
  function disposeAll ( ...var_args : any [] ) : void ;
}
// Generated from third_party/closure/goog/disposable/disposable.js
declare module 'goog:goog.disposeAll' {
  import disposeAll = ಠ_ಠ.clutz.goog.disposeAll;
  export default disposeAll;
}
declare module 'google3/third_party/closure/goog/disposable/disposable' {
  export {};
  const __clutz_multiple_provides: true;
}
